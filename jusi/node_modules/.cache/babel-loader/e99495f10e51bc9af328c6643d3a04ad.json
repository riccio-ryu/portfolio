{"ast":null,"code":"'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function (node, options, parentTagName) {\n  const jObj = {}; // when no child node or attr is present\n\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  } // otherwise create a textnode if node has some text\n\n\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName);\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = options.arrayMode === true && typeof result === 'object' || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  } //add value\n\n\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;","map":{"version":3,"sources":["/Users/youyeonchang/Desktop/portfolio/jusi/node_modules/fast-xml-parser/src/node2json.js"],"names":["util","require","convertToJson","node","options","parentTagName","jObj","alwaysCreateTextNode","child","isEmptyObject","attrsMap","isExist","val","cdataPositionChar","asArray","isTagNameInArrayMode","tagname","arrayMode","textNodeName","merge","keys","Object","index","length","tagName","tag","hasOwnProperty","push","result","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n"]},"metadata":{},"sourceType":"script"}