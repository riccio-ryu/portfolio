{"ast":null,"code":"const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/; // const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n//polyfill\n\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\n\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst consider = {\n  hex: true,\n  leadingZeros: true,\n  decimalPoint: \"\\.\",\n  eNotation: true //skipLike: /regex/\n\n};\n\nfunction toNumber(str) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // const options = Object.assign({}, consider);\n  // if(opt.leadingZeros === false){\n  //     options.leadingZeros = false;\n  // }else if(opt.hex === false){\n  //     options.hex = false;\n  // }\n  options = Object.assign({}, consider, options);\n  if (!str || typeof str !== \"string\") return str;\n  let trimmedStr = str.trim(); // if(trimmedStr === \"0.0\") return 0;\n  // else if(trimmedStr === \"+0.0\") return 0;\n  // else if(trimmedStr === \"-0.0\") return -0;\n\n  if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;else if (options.hex && hexRegex.test(trimmedStr)) {\n    return Number.parseInt(trimmedStr, 16); // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n  } else {\n    //separate negative sign, leading zeros, and rest number\n    const match = numRegex.exec(trimmedStr);\n\n    if (match) {\n      const sign = match[1];\n      const leadingZeros = match[2];\n      let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n      //trim ending zeros for floating number\n\n      const eNotation = match[4] || match[6];\n      if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n      else {\n        //no leading zeros or leading zeros are allowed\n        const num = Number(trimmedStr);\n        const numStr = \"\" + num;\n\n        if (numStr.search(/[eE]/) !== -1) {\n          //given number is long and parsed to eNotation\n          if (options.eNotation) return num;else return str;\n        } else if (eNotation) {\n          //given number has enotation\n          if (options.eNotation) return num;else return str;\n        } else if (trimmedStr.indexOf(\".\") !== -1) {\n          //floating number\n          // const decimalPart = match[5].substr(1);\n          // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n          // const p = numStr.indexOf(\".\");\n          // const givenIntPart = numStr.substr(0,p);\n          // const givenDecPart = numStr.substr(p+1);\n          if (numStr === \"0\" && numTrimmedByZeros === \"\") return num; //0.0\n          else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n          else if (sign && numStr === \"-\" + numTrimmedByZeros) return num;else return str;\n        }\n\n        if (leadingZeros) {\n          // if(numTrimmedByZeros === numStr){\n          //     if(options.leadingZeros) return num;\n          //     else return str;\n          // }else return str;\n          if (numTrimmedByZeros === numStr) return num;else if (sign + numTrimmedByZeros === numStr) return num;else return str;\n        }\n\n        if (trimmedStr === numStr) return num;else if (trimmedStr === sign + numStr) return num; // else{\n        //     //number with +/- sign\n        //     trimmedStr.test(/[-+][0-9]);\n        // }\n\n        return str;\n      } // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n    } else {\n      //non-numeric string\n      return str;\n    }\n  }\n}\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\n\n\nfunction trimZeros(numStr) {\n  if (numStr && numStr.indexOf(\".\") !== -1) {\n    //float\n    numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n\n    if (numStr === \".\") numStr = \"0\";else if (numStr[0] === \".\") numStr = \"0\" + numStr;else if (numStr[numStr.length - 1] === \".\") numStr = numStr.substr(0, numStr.length - 1);\n    return numStr;\n  }\n\n  return numStr;\n}\n\nmodule.exports = toNumber;","map":{"version":3,"sources":["/Users/youyeonchang/Desktop/portfolio/jusi/node_modules/strnum/strnum.js"],"names":["hexRegex","numRegex","Number","parseInt","window","parseFloat","consider","hex","leadingZeros","decimalPoint","eNotation","toNumber","str","options","Object","assign","trimmedStr","trim","skipLike","undefined","test","match","exec","sign","numTrimmedByZeros","trimZeros","length","num","numStr","search","indexOf","replace","substr","module","exports"],"mappings":"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","sourcesContent":["const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n"]},"metadata":{},"sourceType":"script"}