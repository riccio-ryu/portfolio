{"ast":null,"code":"\"use strict\";\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst xml2js = require('xml2js');\n\nconst url = require('url');\n\nconst fields = require('./fields');\n\nconst utils = require('./utils');\n\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml'\n};\nconst DEFAULT_MAX_REDIRECTS = 5;\nconst DEFAULT_TIMEOUT = 60000;\n\nclass Parser {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  parseString(xml, callback) {\n    let prom = new Promise((resolve, reject) => {\n      this.xmlParser.parseString(xml, (err, result) => {\n        if (err) return reject(err);\n\n        if (!result) {\n          return reject(new Error('Unable to parse XML.'));\n        }\n\n        let feed = null;\n\n        if (result.feed) {\n          feed = this.buildAtomFeed(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n          feed = this.buildRSS2(result);\n        } else if (result['rdf:RDF']) {\n          feed = this.buildRSS1(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n          feed = this.buildRSS0_9(result);\n        } else if (result.rss && this.options.defaultRSS) {\n          switch (this.options.defaultRSS) {\n            case 0.9:\n              feed = this.buildRSS0_9(result);\n              break;\n\n            case 1:\n              feed = this.buildRSS1(result);\n              break;\n\n            case 2:\n              feed = this.buildRSS2(result);\n              break;\n\n            default:\n              return reject(new Error(\"default RSS version not recognized.\"));\n          }\n        } else {\n          return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"));\n        }\n\n        resolve(feed);\n      });\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  parseURL(feedUrl, callback) {\n    let redirectCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let xml = '';\n    let get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n    let urlParts = url.parse(feedUrl);\n    let headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n    let timeout = null;\n    let prom = new Promise((resolve, reject) => {\n      const requestOpts = Object.assign({\n        headers\n      }, urlParts, this.options.requestOptions);\n      let req = get(requestOpts, res => {\n        if (this.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n          if (redirectCount === this.options.maxRedirects) {\n            return reject(new Error(\"Too many redirects\"));\n          } else {\n            const newLocation = url.resolve(feedUrl, res.headers['location']);\n            return this.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n          }\n        } else if (res.statusCode >= 300) {\n          return reject(new Error(\"Status code \" + res.statusCode));\n        }\n\n        let encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n        res.setEncoding(encoding);\n        res.on('data', chunk => {\n          xml += chunk;\n        });\n        res.on('end', () => {\n          return this.parseString(xml).then(resolve, reject);\n        });\n      });\n      req.on('error', reject);\n      timeout = setTimeout(() => {\n        return reject(new Error(\"Request timed out after \" + this.options.timeout + \"ms\"));\n      }, this.options.timeout);\n    }).then(data => {\n      clearTimeout(timeout);\n      return Promise.resolve(data);\n    }, e => {\n      clearTimeout(timeout);\n      return Promise.reject(e);\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  buildAtomFeed(xmlObj) {\n    let feed = {\n      items: []\n    };\n    utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n\n    if (xmlObj.feed.link) {\n      feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n      feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n    }\n\n    if (xmlObj.feed.title) {\n      let title = xmlObj.feed.title[0] || '';\n      if (title._) title = title._;\n      if (title) feed.title = title;\n    }\n\n    if (xmlObj.feed.updated) {\n      feed.lastBuildDate = xmlObj.feed.updated[0];\n    }\n\n    feed.items = (xmlObj.feed.entry || []).map(entry => this.parseItemAtom(entry));\n    return feed;\n  }\n\n  parseItemAtom(entry) {\n    let item = {};\n    utils.copyFromXML(entry, item, this.options.customFields.item);\n\n    if (entry.title) {\n      let title = entry.title[0] || '';\n      if (title._) title = title._;\n      if (title) item.title = title;\n    }\n\n    if (entry.link && entry.link.length) {\n      item.link = utils.getLink(entry.link, 'alternate', 0);\n    }\n\n    if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n    if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n    if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n\n    if (entry.content && entry.content.length) {\n      item.content = utils.getContent(entry.content[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n\n    if (entry.summary && entry.summary.length) {\n      item.summary = utils.getContent(entry.summary[0]);\n    }\n\n    if (entry.id) {\n      item.id = entry.id[0];\n    }\n\n    this.setISODate(item);\n    return item;\n  }\n\n  buildRSS0_9(xmlObj) {\n    var channel = xmlObj.rss.channel[0];\n    var items = channel.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS1(xmlObj) {\n    xmlObj = xmlObj['rdf:RDF'];\n    let channel = xmlObj.channel[0];\n    let items = xmlObj.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS2(xmlObj) {\n    let channel = xmlObj.rss.channel[0];\n    let items = channel.item;\n    let feed = this.buildRSS(channel, items);\n\n    if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n      this.decorateItunes(feed, channel);\n    }\n\n    return feed;\n  }\n\n  buildRSS(channel, items) {\n    items = items || [];\n    let feed = {\n      items: []\n    };\n    let feedFields = fields.feed.concat(this.options.customFields.feed);\n    let itemFields = fields.item.concat(this.options.customFields.item);\n\n    if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n      feed.feedUrl = channel['atom:link'][0].$.href;\n    }\n\n    if (channel.image && channel.image[0] && channel.image[0].url) {\n      feed.image = {};\n      let image = channel.image[0];\n      if (image.link) feed.image.link = image.link[0];\n      if (image.url) feed.image.url = image.url[0];\n      if (image.title) feed.image.title = image.title[0];\n      if (image.width) feed.image.width = image.width[0];\n      if (image.height) feed.image.height = image.height[0];\n    }\n\n    const paginationLinks = this.generatePaginationLinks(channel);\n\n    if (Object.keys(paginationLinks).length) {\n      feed.paginationLinks = paginationLinks;\n    }\n\n    utils.copyFromXML(channel, feed, feedFields);\n    feed.items = items.map(xmlItem => this.parseItemRss(xmlItem, itemFields));\n    return feed;\n  }\n\n  parseItemRss(xmlItem, itemFields) {\n    let item = {};\n    utils.copyFromXML(xmlItem, item, itemFields);\n\n    if (xmlItem.enclosure) {\n      item.enclosure = xmlItem.enclosure[0].$;\n    }\n\n    if (xmlItem.description) {\n      item.content = utils.getContent(xmlItem.description[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n\n    if (xmlItem.guid) {\n      item.guid = xmlItem.guid[0];\n      if (item.guid._) item.guid = item.guid._;\n    }\n\n    if (xmlItem.category) item.categories = xmlItem.category;\n    this.setISODate(item);\n    return item;\n  }\n  /**\n   * Add iTunes specific fields from XML to extracted JSON\n   *\n   * @access public\n   * @param {object} feed extracted\n   * @param {object} channel parsed XML\n   */\n\n\n  decorateItunes(feed, channel) {\n    let items = channel.item || [];\n    let categories = [];\n    feed.itunes = {};\n\n    if (channel['itunes:owner']) {\n      let owner = {};\n\n      if (channel['itunes:owner'][0]['itunes:name']) {\n        owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n      }\n\n      if (channel['itunes:owner'][0]['itunes:email']) {\n        owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n      }\n\n      feed.itunes.owner = owner;\n    }\n\n    if (channel['itunes:image']) {\n      let image;\n      let hasImageHref = channel['itunes:image'][0] && channel['itunes:image'][0].$ && channel['itunes:image'][0].$.href;\n      image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n\n      if (image) {\n        feed.itunes.image = image;\n      }\n    }\n\n    if (channel['itunes:category']) {\n      const categoriesWithSubs = channel['itunes:category'].map(category => {\n        return {\n          name: category.$.text,\n          subs: category['itunes:category'] ? category['itunes:category'].map(subcategory => ({\n            name: subcategory.$.text\n          })) : null\n        };\n      });\n      feed.itunes.categories = categoriesWithSubs.map(category => category.name);\n      feed.itunes.categoriesWithSubs = categoriesWithSubs;\n    }\n\n    if (channel['itunes:keywords']) {\n      if (channel['itunes:keywords'].length > 1) {\n        feed.itunes.keywords = channel['itunes:keywords'].map(keyword => keyword.$.text);\n      } else {\n        let keywords = channel['itunes:keywords'][0];\n\n        if (keywords && typeof keywords._ === 'string') {\n          keywords = keywords._;\n        }\n\n        if (keywords && keywords.$ && keywords.$.text) {\n          feed.itunes.keywords = keywords.$.text.split(',');\n        } else if (typeof keywords === \"string\") {\n          feed.itunes.keywords = keywords.split(',');\n        }\n      }\n    }\n\n    utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n    items.forEach((item, index) => {\n      let entry = feed.items[index];\n      entry.itunes = {};\n      utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n      let image = item['itunes:image'];\n\n      if (image && image[0] && image[0].$ && image[0].$.href) {\n        entry.itunes.image = image[0].$.href;\n      }\n    });\n  }\n\n  setISODate(item) {\n    let date = item.pubDate || item.date;\n\n    if (date) {\n      try {\n        item.isoDate = new Date(date.trim()).toISOString();\n      } catch (e) {// Ignore bad date format\n      }\n    }\n  }\n  /**\n   * Generates a pagination object where the rel attribute is the key and href attribute is the value\n   *  { self: 'self-url', first: 'first-url', ...  }\n   *\n   * @access private\n   * @param {Object} channel parsed XML\n   * @returns {Object}\n   */\n\n\n  generatePaginationLinks(channel) {\n    if (!channel['atom:link']) {\n      return {};\n    }\n\n    const paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n    return channel['atom:link'].reduce((paginationLinks, link) => {\n      if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n        return paginationLinks;\n      }\n\n      paginationLinks[link.$.rel] = link.$.href;\n      return paginationLinks;\n    }, {});\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/youyeonchang/Desktop/portfolio/jusi/node_modules/rss-parser/lib/parser.js"],"names":["http","require","https","xml2js","url","fields","utils","DEFAULT_HEADERS","DEFAULT_MAX_REDIRECTS","DEFAULT_TIMEOUT","Parser","constructor","options","headers","customFields","item","feed","requestOptions","maxRedirects","timeout","xmlParser","parseString","xml","callback","prom","Promise","resolve","reject","err","result","Error","buildAtomFeed","rss","$","version","match","buildRSS2","buildRSS1","buildRSS0_9","defaultRSS","maybePromisify","parseURL","feedUrl","redirectCount","get","indexOf","urlParts","parse","Object","assign","requestOpts","req","res","statusCode","newLocation","then","encoding","getEncodingFromContentType","setEncoding","on","chunk","setTimeout","data","clearTimeout","e","xmlObj","items","copyFromXML","link","getLink","title","_","updated","lastBuildDate","entry","map","parseItemAtom","length","published","pubDate","Date","toISOString","author","name","content","getContent","contentSnippet","getSnippet","summary","id","setISODate","channel","buildRSS","decorateItunes","feedFields","concat","itemFields","href","image","width","height","paginationLinks","generatePaginationLinks","keys","xmlItem","parseItemRss","enclosure","description","guid","category","categories","itunes","owner","email","hasImageHref","categoriesWithSubs","text","subs","subcategory","keywords","keyword","split","podcastFeed","forEach","index","podcastItem","date","isoDate","trim","paginationRelAttributes","reduce","includes","rel","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst http = require('http');\nconst https = require('https');\nconst xml2js = require('xml2js');\nconst url = require('url');\n\nconst fields = require('./fields');\nconst utils = require('./utils');\n\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml',\n}\nconst DEFAULT_MAX_REDIRECTS = 5;\nconst DEFAULT_TIMEOUT = 60000;\n\nclass Parser {\n  constructor(options={}) {\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  parseString(xml, callback) {\n    let prom = new Promise((resolve, reject) => {\n      this.xmlParser.parseString(xml, (err, result) => {\n        if (err) return reject(err);\n        if (!result) {\n          return reject(new Error('Unable to parse XML.'));\n        }\n        let feed = null;\n        if (result.feed) {\n          feed = this.buildAtomFeed(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n          feed = this.buildRSS2(result);\n        } else if (result['rdf:RDF']) {\n          feed = this.buildRSS1(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n          feed = this.buildRSS0_9(result);\n        } else if (result.rss && this.options.defaultRSS) {\n          switch(this.options.defaultRSS) {\n            case 0.9:\n              feed = this.buildRSS0_9(result);\n              break;\n            case 1:\n              feed = this.buildRSS1(result);\n              break;\n            case 2:\n              feed = this.buildRSS2(result);\n              break;\n            default:\n              return reject(new Error(\"default RSS version not recognized.\"))\n          }\n        } else {\n          return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"))\n        }\n        resolve(feed);\n      });\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  parseURL(feedUrl, callback, redirectCount=0) {\n    let xml = '';\n    let get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n    let urlParts = url.parse(feedUrl);\n    let headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n    let timeout = null;\n    let prom = new Promise((resolve, reject) => {\n      const requestOpts = Object.assign({headers}, urlParts, this.options.requestOptions);\n      let req = get(requestOpts, (res) => {\n        if (this.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n          if (redirectCount === this.options.maxRedirects) {\n            return reject(new Error(\"Too many redirects\"));\n          } else {\n            const newLocation = url.resolve(feedUrl, res.headers['location']);\n            return this.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n          }\n        } else if (res.statusCode >= 300) {\n          return reject(new Error(\"Status code \" + res.statusCode))\n        }\n        let encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n        res.setEncoding(encoding);\n        res.on('data', (chunk) => {\n          xml += chunk;\n        });\n        res.on('end', () => {\n          return this.parseString(xml).then(resolve, reject);\n        });\n      })\n      req.on('error', reject);\n      timeout = setTimeout(() => {\n        return reject(new Error(\"Request timed out after \" + this.options.timeout + \"ms\"));\n      }, this.options.timeout);\n    }).then(data => {\n      clearTimeout(timeout);\n      return Promise.resolve(data);\n    }, e => {\n      clearTimeout(timeout);\n      return Promise.reject(e);\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  buildAtomFeed(xmlObj) {\n    let feed = {items: []};\n    utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n    if (xmlObj.feed.link) {\n      feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n      feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n    }\n    if (xmlObj.feed.title) {\n      let title = xmlObj.feed.title[0] || '';\n      if (title._) title = title._\n      if (title) feed.title = title;\n    }\n    if (xmlObj.feed.updated) {\n      feed.lastBuildDate = xmlObj.feed.updated[0];\n    }\n    feed.items = (xmlObj.feed.entry || []).map(entry => this.parseItemAtom(entry));\n    return feed;\n  }\n\n  parseItemAtom(entry) {\n    let item = {};\n    utils.copyFromXML(entry, item, this.options.customFields.item);\n    if (entry.title) {\n      let title = entry.title[0] || '';\n      if (title._) title = title._;\n      if (title) item.title = title;\n    }\n    if (entry.link && entry.link.length) {\n      item.link = utils.getLink(entry.link, 'alternate', 0);\n    }\n    if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n    if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n    if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n    if (entry.content && entry.content.length) {\n      item.content = utils.getContent(entry.content[0]);\n      item.contentSnippet = utils.getSnippet(item.content)\n    }\n    if (entry.summary && entry.summary.length) {\n      item.summary = utils.getContent(entry.summary[0]);\n    }\n    if (entry.id) {\n      item.id = entry.id[0];\n    }\n    this.setISODate(item);\n    return item;\n  }\n\n  buildRSS0_9(xmlObj) {\n    var channel = xmlObj.rss.channel[0];\n    var items = channel.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS1(xmlObj) {\n    xmlObj = xmlObj['rdf:RDF'];\n    let channel = xmlObj.channel[0];\n    let items = xmlObj.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS2(xmlObj) {\n    let channel = xmlObj.rss.channel[0];\n    let items = channel.item;\n    let feed = this.buildRSS(channel, items);\n    if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n      this.decorateItunes(feed, channel);\n    }\n    return feed;\n  }\n\n  buildRSS(channel, items) {\n    items = items || [];\n    let feed = {items: []};\n    let feedFields = fields.feed.concat(this.options.customFields.feed);\n    let itemFields = fields.item.concat(this.options.customFields.item);\n    if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n      feed.feedUrl = channel['atom:link'][0].$.href;\n    }\n    if (channel.image && channel.image[0] && channel.image[0].url) {\n      feed.image = {};\n      let image = channel.image[0];\n      if (image.link) feed.image.link = image.link[0];\n      if (image.url) feed.image.url = image.url[0];\n      if (image.title) feed.image.title = image.title[0];\n      if (image.width) feed.image.width = image.width[0];\n      if (image.height) feed.image.height = image.height[0];\n    }\n    const paginationLinks = this.generatePaginationLinks(channel);\n    if (Object.keys(paginationLinks).length) {\n      feed.paginationLinks = paginationLinks;\n    }\n    utils.copyFromXML(channel, feed, feedFields);\n    feed.items = items.map(xmlItem => this.parseItemRss(xmlItem, itemFields));\n    return feed;\n  }\n\n  parseItemRss(xmlItem, itemFields) {\n    let item = {};\n    utils.copyFromXML(xmlItem, item, itemFields);\n    if (xmlItem.enclosure) {\n      item.enclosure = xmlItem.enclosure[0].$;\n    }\n    if (xmlItem.description) {\n      item.content = utils.getContent(xmlItem.description[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n    if (xmlItem.guid) {\n      item.guid = xmlItem.guid[0];\n      if (item.guid._) item.guid = item.guid._;\n    }\n    if (xmlItem.category) item.categories = xmlItem.category;\n    this.setISODate(item);\n    return item;\n  }\n\n  /**\n   * Add iTunes specific fields from XML to extracted JSON\n   *\n   * @access public\n   * @param {object} feed extracted\n   * @param {object} channel parsed XML\n   */\n  decorateItunes(feed, channel) {\n    let items = channel.item || [];\n    let categories = [];\n    feed.itunes = {}\n\n    if (channel['itunes:owner']) {\n      let owner = {};\n\n      if(channel['itunes:owner'][0]['itunes:name']) {\n        owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n      }\n      if(channel['itunes:owner'][0]['itunes:email']) {\n        owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n      }\n      feed.itunes.owner = owner;\n    }\n\n    if (channel['itunes:image']) {\n      let image;\n      let hasImageHref = (channel['itunes:image'][0] &&\n        channel['itunes:image'][0].$ &&\n        channel['itunes:image'][0].$.href);\n      image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n      if (image) {\n        feed.itunes.image = image;\n      }\n    }\n\n    if (channel['itunes:category']) {\n      const categoriesWithSubs = channel['itunes:category'].map((category) => {\n        return {\n          name: category.$.text,\n          subs: category['itunes:category'] ?\n            category['itunes:category']\n              .map((subcategory) => ({ name: subcategory.$.text })) : null,\n        };\n      });\n\n      feed.itunes.categories = categoriesWithSubs.map((category) => category.name);\n      feed.itunes.categoriesWithSubs = categoriesWithSubs;\n    }\n\n    if (channel['itunes:keywords']) {\n      if (channel['itunes:keywords'].length > 1) {\n        feed.itunes.keywords = channel['itunes:keywords'].map(\n          keyword => keyword.$.text\n        );\n      } else {\n        let keywords = channel['itunes:keywords'][0];\n        if (keywords && typeof keywords._ === 'string') {\n          keywords = keywords._;\n        }\n\n        if (keywords && keywords.$ && keywords.$.text) {\n          feed.itunes.keywords = keywords.$.text.split(',')\n        } else if (typeof keywords === \"string\") {\n          feed.itunes.keywords = keywords.split(',');\n        }\n      }\n    }\n\n    utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n    items.forEach((item, index) => {\n      let entry = feed.items[index];\n      entry.itunes = {};\n      utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n      let image = item['itunes:image'];\n      if (image && image[0] && image[0].$ && image[0].$.href) {\n        entry.itunes.image = image[0].$.href;\n      }\n    });\n  }\n\n  setISODate(item) {\n    let date = item.pubDate || item.date;\n    if (date) {\n      try {\n        item.isoDate = new Date(date.trim()).toISOString();\n      } catch (e) {\n        // Ignore bad date format\n      }\n    }\n  }\n\n  /**\n   * Generates a pagination object where the rel attribute is the key and href attribute is the value\n   *  { self: 'self-url', first: 'first-url', ...  }\n   *\n   * @access private\n   * @param {Object} channel parsed XML\n   * @returns {Object}\n   */\n  generatePaginationLinks(channel) {\n    if (!channel['atom:link']) {\n      return {};\n    }\n    const paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n\n    return channel['atom:link'].reduce((paginationLinks, link) => {\n      if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n        return paginationLinks;\n      }\n      paginationLinks[link.$.rel] = link.$.href;\n      return paginationLinks;\n    }, {});\n  }\n}\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}